#!/usr/bin/env python3

"""
create the cam library
"""
# pylint: disable=multiple-imports, wrong-import-position, wildcard-import
# pylint: disable=unused-wildcard-import, bad-whitespace, too-many-locals
# pylint: disable=invalid-name
import sys, os, filecmp, shutil


_CIMEROOT = os.environ.get("CIMEROOT")
if _CIMEROOT is None:
    raise SystemExit("ERROR: must set CIMEROOT environment variable")

_LIBDIR = os.path.join(_CIMEROOT, "CIME", "Tools")
sys.path.append(_LIBDIR)

from standard_script_setup import *
from CIME.case import Case
from CIME.utils import run_sub_or_cmd, expect, run_cmd
from CIME.utils import import_from_file, run_bld_cmd_ensure_logging
from CIME.buildlib import parse_input
from CIME.build import get_standard_makefile_args

logger = logging.getLogger(__name__)

###############################################################################
def get_macro_var(macro_dump, varname):
    ###############################################################################
    look_for = f"{varname} :="
    for line in macro_dump.splitlines():
        if line.startswith(look_for):
            return line.split(":=")[-1].strip()

    return ""

###############################################################################
def extract_from_macros(case, comp_name, extra_vars=()):
    ###############################################################################
    """
    Hacky way of getting stuff from Macros. We use the $case/Macros.make file,
    which gets generated by CIME case.build and run it with -p to print all the
    variables it sets. This is currently the best method we have to query macro
    settings outside of CMake. It handles the COMP_NAME conditionals correctly,
    allowing us to customize things for specific sharedlibs.
    """
    standard_vars = [
        "SFC",
        "SCC",
        "SCXX",
        "MPIFC",
        "MPICC",
        "MPICXX",
        "CMAKE_Fortran_FLAGS",
        "CMAKE_C_FLAGS",
        "CMAKE_CXX_FLAGS",
        "CPPDEFS",
        "CMAKE_EXE_LINKER_FLAGS",
    ]
    all_vars = standard_vars + list(extra_vars)

    make_args = get_standard_makefile_args(case)
    macro_file = os.path.join(case.get_value("CASEROOT"), "Macros.make")
    macro_dump = run_cmd(f"make -f {macro_file} COMP_NAME={comp_name} {make_args} -p")[1]
    result = []
    for macro_var in all_vars:
        macro_val = get_macro_var(macro_dump, macro_var)
        result.append(macro_val)

    return result

###############################################################################
def _build_kokkos(caseroot):
    ###############################################################################

    with Case(caseroot) as case:

        # Only need Kokkos for theta-l and theta-l_kokkos dycores
        cam_dycore = case.get_value("CAM_DYCORE")
        cam_target = case.get_value("CAM_TARGET")
        if cam_dycore != "se" or cam_target not in ["theta-l", "theta-l_kokkos"]:
            print(
                f"Skipping Kokkos build: {cam_dycore} {cam_target}. "
                "Only needed for theta-l and theta-l_kokkos dycores"
            )
            return
        
        # If we are using Albany/Trilinos, we must use the Kokkos that comes with it
        if case.get_value("USE_ALBANY") or case.get_value("USE_TRILINOS"):
            print("case is using Trilinos and will use its Kokkos")
            return

        installed_kokkos_dir = os.environ.get("Kokkos_ROOT")
        if installed_kokkos_dir is not None:
            # We are trying to use a pre-installed kokkos. Look for the relevant folders/libs,
            # and if all looks good, return. Otherwise, crap out
            kokkos_root = os.path.abspath(installed_kokkos_dir)
            include_dir = os.path.join(kokkos_root, "include")

            expect(
                os.path.isdir(kokkos_root),
                f"Non-existent kokkos install dir '{kokkos_root}'",
            )
            expect(
                os.path.isdir(include_dir),
                f"Missing include subfolder in kokkos install dir '{kokkos_root}'",
            )
            expect(
                os.path.isfile(os.path.join(include_dir, "Kokkos_Core.hpp")),
                f"Missing kokkos headers in '{include_dir}'",
            )

            lib_dir = None
            for subdir in ["lib64", "lib"]:
                potential_lib_dir = os.path.join(kokkos_root, subdir)
                if os.path.isdir(potential_lib_dir):
                    lib_dir = potential_lib_dir
                    for libs in ["libkokkoscontainers.so","libkokkoscore.so","libkokkossimd.so"]:
                        expect(
                            os.path.isfile(os.path.join(lib_dir, libs)),
                            f"Missing {libs} in '{lib_dir}'",
                        )

            expect(
                lib_dir is not None,
                f"Missing library folder (lib64 or lib) in kokkos install dir '{kokkos_root}'",
            )

            print(f"Using pre-installed Kokkos_ROOT: {kokkos_root}")
            return
        else:
            print("no value found in env for Kokkos_ROOT. building from scratch")

        srcroot = case.get_value("SRCROOT")
        kokkos_dir = os.path.join(srcroot, "libraries", "kokkos")
        expect(os.path.isdir(kokkos_dir), "Missing kokkos submodule")

        # We want to get the compiler and kokkos_options from Macros.make
        # (generated from cmake_macros), but we want to otherwise
        # let kokkos control flags
        macro_vals = extract_from_macros(case, "kokkos", extra_vars=("KOKKOS_OPTIONS",))
        cxx, kokkos_options_raw = macro_vals[2], macro_vals[-1]

        kokkos_options = kokkos_options_raw.split(":=")[-1].strip()

        # We will take care of setting CMAKE_CXX_COMPILER unless user has explictly
        # set one in their KOKKOS_OPTIONS.
        if "DCMAKE_CXX_COMPILER" not in kokkos_options:
            if "Kokkos_ENABLE_CUDA" in kokkos_options:
                cxx = os.path.join(kokkos_dir, "bin/nvcc_wrapper")

            if "/" in cxx:
                cxx = "-DCMAKE_CXX_COMPILER={}".format(cxx)
            else:
                cxx_path = shutil.which(cxx)
                expect(cxx_path is not None, "{} is not in PATH?".format(cxx))
                cxx = "-DCMAKE_CXX_COMPILER={}".format(cxx_path)

        gmake_cmd = case.get_value("GMAKE")
        gmake_j = case.get_value("GMAKE_J")

        if case.get_value("DEBUG"):
            strdebug = "debug"
        else:
            strdebug = "nodebug"

        if case.get_value("BUILD_THREADED"):
            strthread = "threads"
        else:
            strthread = "nothreads"

        mpilib = case.get_value("MPILIB")
        sharedpath = os.path.join(case.get_value("COMPILER"), mpilib, strdebug, strthread)
        slr = os.path.abspath(case.get_value("SHAREDLIBROOT"))
        kokkosbuildroot = os.path.join(slr, sharedpath)

        gen_makefile_cmd = f"cmake {kokkos_options} {cxx} -DUSE_KOKKOS=TRUE -DCMAKE_CXX_STANDARD=17 -DCMAKE_INSTALL_PREFIX={kokkosbuildroot} {kokkos_dir}"

        kokkosbuildpath = f"{kokkosbuildroot}/kokkos/build"
        if not os.path.isdir(kokkosbuildpath):
            os.makedirs(kokkosbuildpath)

        run_bld_cmd_ensure_logging(gen_makefile_cmd, logger, from_dir=kokkosbuildpath)
        run_bld_cmd_ensure_logging(
            "{} VERBOSE=1 -j {}".format(gmake_cmd, gmake_j), logger, from_dir=kokkosbuildpath
        )
        run_bld_cmd_ensure_logging("{} install".format(gmake_cmd), logger, from_dir=kokkosbuildpath)

###############################################################################
def _build_fms(caseroot, libroot, bldroot):
    ###############################################################################

    with Case(caseroot) as case:

        # Only need FMS for fv3 dycore
        cam_dycore = case.get_value("CAM_DYCORE")
        srcroot = case.get_value("SRCROOT")
        if cam_dycore == "fv3":
            # first check for the external FMS library and build it
            # Check to see if some other component built it already
            fmsbuildlib = os.path.join(srcroot, "libraries", "FMS", "buildlib")
            librootfms = os.path.join(libroot, "libfms.a")
            if not os.path.exists(librootfms):
                if case.get_value("DEBUG"):
                    strdebug = "debug"
                else:
                    strdebug = "nodebug"

                if case.get_value("BUILD_THREADED"):
                    strthread = "threads"
                else:
                    strthread = "nothreads"

                mpilib = case.get_value("MPILIB")
                sharedpath = os.path.join(case.get_value("COMPILER"), mpilib,
                                          strdebug, strthread)
                slr = os.path.abspath(case.get_value("SHAREDLIBROOT"))
                fmsbuildroot = os.path.join(slr, sharedpath)
                fmsinstallpath = os.path.join(fmsbuildroot, "FMS")
                install_libfms = os.path.join(fmsinstallpath, "libfms.a")

                if not os.path.exists(install_libfms):
                    if not os.path.exists(fmsbuildlib):
                        #todo: call checkout_externals to get this component
                        expect(False, "FMS external not found")
                    else:
                        stat, _, err = run_cmd(f"{fmsbuildlib} {fmsbuildroot} {fmsinstallpath} {caseroot}", verbose=True)
                        expect(stat==0, f"FMS build Failed {err}")

                if os.path.exists(install_libfms):
                    shutil.copy(install_libfms, libroot)

###############################################################################
def _build_cam(caseroot, libroot, bldroot):
    ###############################################################################

    with Case(caseroot, read_only=False) as case:

        srcroot = case.get_value("SRCROOT")
        # -------------------------------------------------------
        # Call cam's buildcpp
        # -------------------------------------------------------
        testpath = os.path.join(srcroot, "components", "cam")
        if os.path.exists(testpath):
            srcroot = testpath

        cmd = os.path.join(os.path.join(srcroot, "cime_config", "buildcpp"))
        logger.info("     ...calling cam buildcpp to set build time options")
        try:
            buildcpp = import_from_file("buildcpp", cmd)
            cam_cppdefs = buildcpp.buildcpp(case)
        except:
            raise RuntimeError("CAM's 'buildcpp' script failed to run properly.")

    with Case(caseroot) as case:

        casetools = case.get_value("CASETOOLS")
        srcroot = case.get_value("SRCROOT")
        gmake_j = case.get_value("GMAKE_J")
        gmake = case.get_value("GMAKE")
        mach = case.get_value("MACH")
        user_incldir = None
        cam_dycore = case.get_value("CAM_DYCORE")
        if cam_dycore == "fv3":
            slr = os.path.abspath(case.get_value("SHAREDLIBROOT"))
            compiler = case.get_value("COMPILER")
            mpilib = case.get_value("MPILIB")
            debug = "debug" if case.get_value("DEBUG") else "nodebug"
            threaded = "threads" if case.get_value("BUILD_THREADED") or case.get_value("FORCE_BUILD_SMP") else "nothreads"
            comp_interface = case.get_value("COMP_INTERFACE")
            fmsbuilddir = os.path.join(
                slr, compiler, mpilib, debug, threaded, "FMS")
            user_incldir = '"-I{} -I{} -I{}"'.format(
                os.path.join(srcroot, "libraries", "FMS", "src", "include"),
                os.path.join(srcroot, "libraries", "FMS", "src", "mpp", "include"),
                fmsbuilddir)

        # -------------------------------------------------------
        # Filepath is created in caseroot/camconf by the call
        # to buildcpp - this needs to be copied to bldroot
        # -------------------------------------------------------
        filesrc = os.path.join(caseroot, "Buildconf", "camconf", "Filepath")
        filedst = os.path.join(bldroot, "Filepath_tmp")
        shutil.copy(filesrc, filedst)

        filedst = os.path.join(bldroot, "Filepath")
        filedst_tmp = os.path.join(bldroot, "Filepath_tmp")
        if os.path.isfile(filedst):
            if not filecmp.cmp(filedst_tmp, filedst):
                shutil.move(filedst_tmp, filedst)
        else:
            shutil.move(filedst_tmp, filedst)

        # -------------------------------------------------------
        # fms is needed by fv3 and should have been built by the framework
        # -------------------------------------------------------
        if cam_dycore == "fv3":
            libfms = os.path.join(fmsbuilddir, "libfms.a")
            expect(os.path.isfile(libfms), "FMS library not found {}".format(libfms))
            shutil.copy(libfms, libroot)

        # -------------------------------------------------------
        # Kokkos is needed by theta-l and theta-l_kokkos dycores and should have been built by the framework
        # -------------------------------------------------------
        cam_target = case.get_value("CAM_TARGET")
        if cam_dycore == "se" and cam_target in ["theta-l", "theta-l_kokkos"]:
            installed_kokkos_dir = os.environ.get("Kokkos_ROOT")
            # If we are using a pre-installed Kokkos, we don't need to copy the libraries as they should be taken care of already
            if installed_kokkos_dir is None:
                if case.get_value("DEBUG"):
                    strdebug = "debug"
                else:
                    strdebug = "nodebug"

                if case.get_value("BUILD_THREADED"):
                    strthread = "threads"
                else:
                    strthread = "nothreads"

                mpilib = case.get_value("MPILIB")
                sharedpath = os.path.join(case.get_value("COMPILER"), mpilib, strdebug, strthread)
                slr = os.path.abspath(case.get_value("SHAREDLIBROOT"))
                kokkosbuildroot = os.path.join(slr, sharedpath)

                for libs in ["libkokkoscontainers.a", "libkokkoscore.a", "libkokkossimd.a"]:
                    libkokkos = os.path.join(kokkosbuildroot, "lib64", libs)
                    if os.path.isfile(libkokkos):
                        shutil.copy(libkokkos, libroot)
                    else:
                        expect(False, f"Kokkos library not found for {libkokkos}")

        # -------------------------------------------------------
        # build the library
        # -------------------------------------------------------
        complib = os.path.join(libroot, "libatm.a")
        makefile = os.path.join(casetools, "Makefile")

        cmd = "{} complib -j {} COMP_NAME=cam COMPLIB={} -f {} {} ".format(
            gmake, gmake_j, complib, makefile, get_standard_makefile_args(case)
        )   
        if cam_cppdefs:
            cmd += " USER_CPPDEFS='{}'".format(cam_cppdefs)

        if user_incldir:
            cmd += " USER_INCLDIR={}".format(user_incldir)

        if cam_dycore == "se" and cam_target in ["theta-l", "theta-l_kokkos"]:
            cmd += " KOKKOS_CMAKE=yes "
            
        rc, out, err = run_cmd(cmd)
        logger.info("%s: \n\n output:\n %s \n\n err:\n\n%s\n", cmd, out, err)
        expect(rc == 0, "Command %s failed with rc=%s" % (cmd, rc))


###############################################################################


def _main_func():
    caseroot, libroot, bldroot = parse_input(sys.argv)
    _build_fms(caseroot, libroot, bldroot)
    _build_kokkos(caseroot)
    _build_cam(caseroot, libroot, bldroot)


###############################################################################

if __name__ == "__main__":
    _main_func()
